# filename: decisiontree_api.py
import pandas as pd
from fastapi import FastAPI, UploadFile, File
from pydantic import BaseModel
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from PIL import Image
import pytesseract
import io
import re
from fastapi.middleware.cors import CORSMiddleware
import asyncio
from collections import OrderedDict
from typing import List

# Windows Tesseract path
pytesseract.pytesseract.tesseract_cmd = r"C:\Program Files\Tesseract-OCR\tesseract.exe"

# ---------------------------
# Input Schema
# ---------------------------
class StudentInput(BaseModel):
    python: int
    sql: int
    java: int

# ---------------------------
# Train Structured Data Model
# ---------------------------
df = pd.read_csv("cs_students.csv")

features = ["Python", "SQL", "Java"]
target = "Future Career"

data = df.copy()
labelEncoders = {}

for col in features:
    if data[col].dtype == "object":
        le = LabelEncoder()
        data[col] = le.fit_transform(data[col])
        labelEncoders[col] = le

targetEncoder = LabelEncoder()
data[target] = targetEncoder.fit_transform(data[target])

X = data[features]
y = data[target]

model = RandomForestClassifier(n_estimators=50, max_depth=8, random_state=42)
model.fit(X, y)

# ---------------------------
# FastAPI App with CORS
# ---------------------------
app = FastAPI(title="Career Prediction API (TOR/COG + Certificates ðŸš€)")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ---------------------------
# Subject Groups & Buckets
# ---------------------------
subjectGroups = {
    "programming": ["programming", "java", "python", "c++", "c#", "software", "coding"],
    "databases": ["database", "sql", "dbms"],
    "networking": ["networking", "networks", "security", "cloud"],
    "webdev": ["html", "css", "javascript", "web", "frontend", "backend", "php"],
    "ai_ml": ["ai", "machine learning", "ml", "data mining"],
    "systems": ["operating systems", "os", "computer systems", "architecture"]
}

bucketMap = {
    "programming": "Java",
    "databases": "SQL",
    "ai_ml": "Python"
}

ignore_keywords = [
    "course", "description", "final", "remarks", "re-exam", "units",
    "fullname", "year level", "program", "college", "student no",
    "academic year", "date printed", "gwa", "credits"
]

# ---------------------------
# Career â†’ Required Skills Map (hardcoded)
# ---------------------------
careerSkillMap = {
    "Software Engineer": ["programming", "databases"],
    "Data Scientist": ["ai_ml", "programming", "databases"],
    "Cloud Solutions Architect": ["networking", "databases", "programming"],
    "Web Developer": ["webdev", "programming", "databases"],
    "Computer Vision Engineer": ["ai_ml", "programming"],
    "NLP Research Scientist": ["ai_ml", "programming"]
}

# ---------------------------
# Hardcoded Certificate Suggestions per career
# ---------------------------
careerCertSuggestions = {
    "Software Engineer": "Recommended: AWS Cloud Practitioner, Oracle Java SE.",
    "Web Developer": "Recommended: FreeCodeCamp, Meta Frontend Dev, Responsive Web Design.",
    "Data Scientist": "Recommended: Google Data Analytics, TensorFlow Developer Cert.",
    "Database Administrator": "Recommended: Oracle SQL Associate, Microsoft SQL Server.",
    "Cloud Solutions Architect": "Recommended: AWS Solutions Architect, Azure Fundamentals.",
    "Cybersecurity Specialist": "Recommended: CompTIA Security+, Cisco CyberOps Associate.",
    "General Studies": "Recommended: Short IT courses to explore career interests."
}

# ---------------------------
# Helpers
# ---------------------------
def normalize_subject(subject: str) -> str:
    return re.sub(r'[^a-z0-9\s+#]', '', subject.lower().strip())

def convert_grade(val: str) -> int:
    """Return grade exactly as numeric (1â€“5)."""
    if re.match(r'^\d+(\.\d+)?$', val):
        num = float(val)
        if num.is_integer():
            return int(num)
        return round(num, 2)
    return None

def extractSubjectGrades(text: str):
    """
    Ultra-flexible subject + grade extractor for noisy COG OCR.
    Keeps any line with a trailing grade-like number, skips only obvious garbage.
    """
    rawSubjects = OrderedDict()
    lines = [l.strip() for l in text.splitlines() if l.strip()]

    print("\n=== OCR RAW TEXT START ===")
    for line in lines:
        print(line)
    print("=== OCR RAW TEXT END ===\n")

    for line in lines:
        lower_line = line.lower()

        # Skip obvious metadata / garbage lines
        if any(kw in lower_line for kw in [
            "fullname", "year level", "course", "description",
            "final", "remarks", "re-exam", "units", "credits",
            "gwa", "date printed", "academic year"
        ]):
            continue

        # Match grade at end (handles 1, 1.0, 1.50, l.50, I.50 OCR errors)
        match = re.search(r'([0-5lI]\.\d{1,2}|[0-5])$', line)
        if not match:
            continue

        gradeVal = match.group(1).replace("l", "1").replace("I", "1")
        gradeNum = convert_grade(gradeVal)
        if gradeNum is None:
            continue

        # Subject = everything before the grade
        subject = line[:match.start()].strip(" -:\t_")

        # If subject text looks empty, keep at least line prefix
        if len(subject) < 2:
            subject = line.strip()

        # Clean subject
        subject = re.sub(r'[_â€“â€”]+', " ", subject)
        subject = re.sub(r'\s{2,}', " ", subject)

        print(f"[KEPT] {subject} -> {gradeNum}")  # DEBUG log

        rawSubjects[subject] = gradeNum

    if not rawSubjects:
        print("âš ï¸ No subjects matched. Try adjusting filters or OCR quality.")

    # -------------------------
    # Map subjects to groups
    # -------------------------
    normalizedText, mappedSkills = {}, {}
    bucketScores = {"Java": [], "SQL": [], "Python": []}

    for group, keywords in subjectGroups.items():
        groupGrades = [
            grade for subj, grade in rawSubjects.items()
            if any(k in normalize_subject(subj) for k in keywords)
        ]
        if groupGrades:
            avgGrade = round(sum(groupGrades) / len(groupGrades))
            normalizedText[group] = avgGrade
            mappedSkills[group] = (
                "Strong" if avgGrade == 1 else
                "Average" if avgGrade == 2 else
                "Weak"
            )
            if group in bucketMap:
                bucketScores[bucketMap[group]].extend(groupGrades)

    finalBuckets = {b: (round(sum(v)/len(v)) if v else 3) for b, v in bucketScores.items()}
    return rawSubjects, normalizedText, mappedSkills, finalBuckets

# ---------------------------
# Predict with Suggestions
# ---------------------------
def predictCareerWithSuggestions(finalBuckets: dict, normalizedText: dict):
    dfInput = pd.DataFrame([{ 
        "Python": finalBuckets["Python"],
        "SQL": finalBuckets["SQL"],
        "Java": finalBuckets["Java"],
    }])

    proba = model.predict_proba(dfInput)[0]
    careers = [
        {"career": targetEncoder.inverse_transform([i])[0], "confidence": round(float(p)*100, 2)}
        for i, p in enumerate(proba)
    ]
    careers = sorted(careers, key=lambda x: x["confidence"], reverse=True)[:3]

    # add skill + cert suggestions
    for c in careers:
        suggestions = []
        if "Developer" in c["career"] or "Engineer" in c["career"]:
            if finalBuckets["Java"] >= 2:
                suggestions.append("Improve Java fundamentals for better software engineering roles.")
        if "Data" in c["career"] or "AI" in c["career"]:
            if finalBuckets["Python"] >= 2:
                suggestions.append("Boost Python and ML-related subjects for stronger data career paths.")
        if "Database" in c["career"] or "Architect" in c["career"]:
            if finalBuckets["SQL"] >= 2:
                suggestions.append("Sharpen SQL and database design knowledge to excel in DB careers.")

        for skill, grade in finalBuckets.items():
            if grade == 3:
                suggestions.append(f"Strengthen your {skill} skills to boost opportunities.")
            elif grade == 2:
                suggestions.append(f"Improving {skill} will help you qualify for more advanced roles.")

        if not suggestions:
            suggestions.append(f"Great work! Youâ€™re already strong for {c['career']}.")

        # attach hardcoded cert suggestion
        c["suggestion"] = " ".join(suggestions)
        c["certificates"] = careerCertSuggestions.get(c["career"], "Consider general IT certifications.")

    return careers

# ---------------------------
# Analyze uploaded certificates (by filename)
# ---------------------------
certificateSuggestions = {
    "aws": "Your AWS certificate strengthens Cloud Architect and DevOps career paths.",
    "ccna": "Your CCNA boosts Networking and Systems Administrator opportunities.",
    "datascience": "Data Science certificate aligns well with AI/ML and Data Scientist roles.",
    "webdev": "Web Development certificate enhances your frontend/backend developer profile.",
    "python": "Python certification supports Data Science, AI, and Software Engineering careers."
}

def analyzeCertificates(certFiles: List[UploadFile]):
    results = []
    for cert in certFiles:
        certName = cert.filename.lower()
        matched = [msg for key, msg in certificateSuggestions.items() if key in certName]
        if not matched:
            matched = [f"Certificate '{cert.filename}' adds additional value to your career profile."]
        results.append({"file": cert.filename, "suggestions": matched})
    return results

# ---------------------------
# Routes
# ---------------------------
@app.post("/ocrPredict")
async def ocrPredict(file: UploadFile = File(...), certificateFiles: List[UploadFile] = File(None)):
    try:
        # OCR on uploaded TOR/COG
        imageBytes = await file.read()
        img = Image.open(io.BytesIO(imageBytes))
        text = await asyncio.to_thread(pytesseract.image_to_string, img)

        rawSubjects, normalizedText, mappedSkills, finalBuckets = extractSubjectGrades(text.strip())
        careerOptions = predictCareerWithSuggestions(finalBuckets, normalizedText)

        # Ensure fallback career
        if not careerOptions:
            careerOptions = [{
                "career": "General Studies",
                "confidence": 50.0,
                "suggestion": "Add more subjects or improve grades for a better match.",
                "certificates": careerCertSuggestions["General Studies"]
            }]

        # Handle Certificates safely
        certResults = []
        if certificateFiles:
            certResults = analyzeCertificates(certificateFiles or [])
        else:
            certResults = [{"info": "No certificates uploaded"}]

        return {
            "careerPrediction": careerOptions[0]["career"],
            "careerOptions": careerOptions,
            "rawSubjects": list(rawSubjects.items()),
            "normalizedText": normalizedText,
            "mappedSkills": mappedSkills,
            "finalBuckets": finalBuckets,
            "certificates": certResults
        }
    except Exception as e:
        return {"error": str(e)}
